package aoc;

import java.util.*;


public class Volcano {
  private Map<String, Valve> valves;
  private int idCounter;
  private Map<String, Map<Set<String>, Map<Integer, Integer>>> pressures;
  private Map<String, Map<String, Path>> paths;
  private Set<String> all;

  public Volcano() {
    valves = new HashMap();
    pressures = new HashMap();
    paths = new HashMap();
  }

  public void addValve(Valve v) {
    valves.put(v.id, v);
  }
  public int getPressure() {
    int i = 1;
    for (Valve s : valves.values()) {
      fillPaths(s);
    }
    setAll();
    return getPressure("AA", new HashSet<String>(), 30);
  }

  public int getPressure(String me, String el, Set<String> visited, int time) {
    Valve curr = valves.get(me);
    Valve elep = valves.get(el);
    if (time < 2) return 0;
    if (time == 2) return curr.getFlow();
    if (time > 24) System.out.println("Yee");
    Set<String> vis = new HashSet<>(visited);
    vis.add(me);
    vis.add(el);

    if (pressures.get(me) == null) pressures.put(me, new HashMap());
    if (pressures.get(me).get(visited) == null)
      pressures.get(me).put(visited, new HashMap());
    if (pressures.get(me).get(visited).containsKey(time)) {
      return pressures.get(me).get(visited).get(time);
    }
    if (pressures.get(el) == null) pressures.put(el, new HashMap());
    if (pressures.get(el).get(visited) == null)
      pressures.get(el).put(visited, new HashMap());
    if (pressures.get(el).get(visited).containsKey(time)) {
      return pressures.get(el).get(visited).get(time);
    }

    int startTime = time;
    int maxme = 0;
    int maxel = 0;
    int secel = 0;
    if (!current.equals("AA")) {
      time--;
      maxme = (time) * curr.getFlow();
      maxel = (secel = (time) * curr.getFlow());
    }
    Map<String, Path> pathsme = paths.get(me);
    Set<String> filtme = filterPaths(pathsme, vis);
    String resme = "";
    for (String valve : filtme) {
      int r = ret + getPressure(valve, vis, time - paths.get(me).get(valve).dist);
      if (r > maxme) {
        maxme = r;
        resme = valve;
      }
    }
    pressures.get(current).get(visited).put(startTime, max);

    Map<String, Path> pathsel = paths.get(el);
    Set<String> filtel = filterPaths(pathsel, vis);
    String resel = "";
    for (String valve : filtel) {
      int r = ret + getPressure(valve, vis, time - paths.get(current).get(valve).dist);
      if (r > maxel) {
        secel = maxel;
        maxel = r;
        resel = valve;
      }
    }
    int result = maxme + ;
    if (resel.equals(resme)) {

    }
    pressures.get(me).get(visited).put(startTime, maxme);
    pressures.get(el).get(visited).put(startTime, maxel);

    return max;
  }

  private void fillPaths(Valve a) {
    paths.put(a.id, new HashMap());
    for (Valve valve : valves.values()) {
      valve.dist = Integer.MAX_VALUE/4;
      valve.parent = null;
    }

    a.dist = 0;
    PriorityQueue<Valve> pq = new PriorityQueue();
    pq.add(a);
    Set<String> visited = new HashSet();

    while (!pq.isEmpty()) {
      Valve v = pq.poll();
      visited.add(v.id);

      for (String neigh : v.getNeighbours()) {
        if (visited.contains(neigh)) continue;
        if (valves.get(neigh).dist > v.dist+1) {
          valves.get(neigh).parent = v.id;
          valves.get(neigh).dist = v.dist+1;
        }
        pq.add(valves.get(neigh));
      }
    }

    for (Valve b : valves.values()) {
      if (a == b) continue;
      LinkedList<String> path = new LinkedList();
      Valve parent = b;
      while (parent != null) {
        if (parent.getFlow() != 0)
          path.add(parent.id);
        parent = valves.get(parent.parent);
      }
      Collections.reverse(path);
      paths.get(a.id).put(b.id, new Path(path, b.dist));
    }
  }

  private void setAll() {
    all = new HashSet();
    for (Valve v : valves.values()) {
      if (v.getFlow() != 0) all.add(v.id);
    }
  }

  private Set<String> filterLinkedList(LinkedList<String> path) {
    Set<String> filtered = new HashSet();
    int max = 0;
    for (String s : path) {
      max = Math.max(max, valves.get(s).getFlow());
      if (valves.get(s).getFlow() != max) {
        filtered.add(s);
      }
    }
    return filtered;
  }

  private Set<String> filterPaths(Map<String, Path> pths,
      Set<String> ignore) {
    Set<String> res = new HashSet(all);
    for (Path path : pths.values()) {
      LinkedList<String> p = new LinkedList(path.path);
      for (String ign : ignore) {
        p.remove(ign);
      }
      Set<String> filtered = filterLinkedList(p);
      res.removeAll(filtered);
    }
    for (String ign : ignore) {
      res.remove(ign);
    }
    return res;
  }


  private class Path {
    LinkedList<String> path;
    int dist;

    public Path(LinkedList<String> path, int dist) {
      this.path = path;
      this.dist = dist;
    }
  }

}
